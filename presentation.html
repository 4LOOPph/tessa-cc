<!doctype html>
<title>Tessa Presentation</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
<style>
body,
html {
    text-align: center;
    color: white;
    overflow: hidden;
    margin: 0;
}

.starter-template {
    padding: 40px 15px;
    text-align: center;
}

.local-media,
.remote-media {
    max-width: 100%;
    max-height: 70%;
}

.local-media-small,
.remote-media-small {
    width: 20%;
    position: fixed;
    bottom: 0;
    left: 0;
}

button {
    display: inline-block;
    outline: 0;
    color: white;
    background: #4472b9;
    white-space: nowrap;
    border: 5px solid #4472b9 !important;
    font-family: 'Gotham Rounded A', 'Gotham Rounded B', sans-serif;
    font-weight: 500;
    font-style: normal;
    padding: 9px 16px !important;
    line-height: 1.4;
    position: relative;
    border-radius: 10px;
    -webkit-box-shadow: 5px 5px 0 0 rgba(0, 0, 0, 0.15);
    box-shadow: 5px 5px 0 0 rgba(0, 0, 0, 0.15);
    -webkit-transition: 0.1s;
    transition: 0.1s;
}

button:hover,
button:active,
button:focus {
    background: #04C;
}

button[disabled] {
    background: transparent;
    border-color: rgb(83, 81, 81);
    color: rgb(139, 133, 133);
}

#container {
    padding-bottom: 100px;
    -webkit-perspective: 1000;
    /* Permalink - use to edit and share this gradient: http://colorzilla.com/gradient-editor/#ffffff+0,d3edff+100 */
    /* Permalink - use to edit and share this gradient: http://colorzilla.com/gradient-editor/#ffffff+0,d3edff+57 */
    background: rgb(255, 255, 255);
    /* Old browsers */
    background: -moz-linear-gradient(top, rgba(255, 255, 255, 1) 0%, rgba(211, 237, 255, 1) 57%);
    /* FF3.6-15 */
    background: -webkit-linear-gradient(top, rgba(255, 255, 255, 1) 0%, rgba(211, 237, 255, 1) 57%);
    /* Chrome10-25,Safari5.1-6 */
    background: linear-gradient(to bottom, rgba(255, 255, 255, 1) 0%, rgba(211, 237, 255, 1) 57%);
    /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
    filter: progid: DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#d3edff', GradientType=0);
    /* IE6-9 */
    height: 100vh;
    width: 100%;
    margin: auto !important;
}

#card {
    -webkit-transform-style: preserve-3d !important;
    -webkit-transition-duration: 2s !important;
    -webkit-transition-property: rotation !important;
    position: absolute;
}

#local {
    -webkit-backface-visibility: hidden !important;
    -webkit-transform: scale(-1, 1) !important;
    position: absolute;
    width: 100vw;
}

#remote {
    /* -webkit-backface-visibility: hidden; */
    /* -webkit-transform: rotateY(180deg); */
    /* position: absolute; */
    width: 100%;
    /* margin-left: 9%; */
}

#remote:-webkit-full-screen {
    margin-left: 0;
}

#remote:-webkit-full-screen {
    margin-left: 0;
}

#remote:-moz-full-screen {
    margin-left: 0;
}

#remote:-ms-fullscreen {
    margin-left: 0;
}

#remote:full-screen {
    margin-left: 0;
}

#remote:fullscreen {
    margin-left: 0;
}

#mini {
    /* -webkit-transform: scale(-1, 1); */
    bottom: 0;
    height: 30%;
    opacity: 1.0;
    position: absolute;
    right: 4px;
    width: 30%;
}

#remoteVideo {
    -webkit-transition-duration: 2s;
    -webkit-transition-property: opacity;
    height: 100%;
    opacity: 0;
    width: 100%;
}

#info-bar {
    /**bottom: 55%;**/
    height: 38px;
    line-height: 38px;
    /**position: absolute;**/
    text-align: center;
    width: 100%;
    font-size: 24px;
    font-family: "Arial";
    color: #308ECC;
    /**top:300px;**/
    text-transform: uppercase;
    font-weight: bold;
}

#logo {
    width: 100%;
    margin-bottom: 180px;
}

#logo img {
    bottom: 55%;
    height: 220px;
    margin: auto;
    text-align: center;
}

#table-div {
    display: table;
    width: 100%;
}

#cell-div {
    display: table-cell;
    vertical-align: middle;
    height: 100vh;
}


/* The loader container */

.loader {
    height: 20px;
    width: 250px;
    /**position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;**/
    margin: auto;
}

.loader--dot {
    animation-name: loader;
    animation-timing-function: ease-in-out;
    animation-duration: 3s;
    animation-iteration-count: infinite;
    height: 15px;
    width: 15px;
    border-radius: 100%;
    position: absolute;
}

.loader--dot:first-child {
    background-color: rgba(48, 142, 204, .3);
    opacity: 0.4;
    animation-delay: 0.5s;
}

.loader--dot:nth-child(2) {
    background-color: rgba(48, 142, 204, .3);
    opacity: 0.5;
    animation-delay: 0.4s;
}

.loader--dot:nth-child(3) {
    background-color: rgba(48, 142, 204, .3);
    opacity: 0.6;
    animation-delay: 0.3s;
}

.loader--dot:nth-child(4) {
    background-color: rgba(48, 142, 204, .3);
    opacity: 0.7;
    animation-delay: 0.2s;
}

.loader--dot:nth-child(5) {
    background-color: rgba(48, 142, 204, .3);
    opacity: 0.8;
    animation-delay: 0.1s;
}

.loader--dot:nth-child(6) {
    background-color: rgba(48, 142, 204, .3);
    animation-delay: 0s;
}

@keyframes loader {
    15% {
        transform: translateX(0);
    }
    45% {
        transform: translateX(230px);
    }
    65% {
        transform: translateX(230px);
    }
    95% {
        transform: translateX(0);
    }
}
</style>
<div id="container" ondblclick="enterFullScreen()">
    <div id="table-div">
        <div id="cell-div">
            <div id="card">
                <div id="remote">
                    <video id="remoteVideo" autoplay="autoplay"></video>
                </div>
            </div>
            <div id="logo">
                <img src="images/tessa-logo.svg">
            </div>
            <div id="loader" class='loader'>
                <div class='loader--dot'></div>
                <div class='loader--dot'></div>
                <div class='loader--dot'></div>
                <div class='loader--dot'></div>
                <div class='loader--dot'></div>
                <div class='loader--dot'></div>
                <div class='loader--text'></div>
            </div>
            <br>
            <div id="info-bar"></div>
        </div>
    </div>
</div>
<script src="https://cdn.rawgit.com/4LOOPph/projects/master/RTCMultiConnection.client.js"></script>
<script src="https://cdn.rawgit.com/4LOOPph/projects/master/CodecsHandler.js"></script>
<script src="https://cdn.rawgit.com/4LOOPph/projects/master/websocket.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="https://cdn.rawgit.com/needim/noty/master/js/noty/packaged/jquery.noty.packaged.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.min.js"></script>
<script>
(function() {
    var params = {},
        r = /([^&=]+)=?([^&]*)/g;

    function d(s) {
        return decodeURIComponent(s.replace(/\+/g, ' '));
    }

    var match, search = window.location.search;
    while (match = r.exec(search.substring(1)))
        params[d(match[1])] = d(match[2]);

    window.params = params;
})();

function setBandwidth(connection) {
    // www.RTCMultiConnection.org/docs/bandwidth/
    connection.bandwidth = {};
    connection.bandwidth.video = connection.bandwidth.screen = 512;
    connection.bandwidth.audio = 128;

    connection.processSdp = function(sdp) {
        if (DetectRTC.isMobileDevice || DetectRTC.browser.name === 'Firefox') {
            return sdp;
        }

        sdp = CodecsHandler.setApplicationSpecificBandwidth(sdp, connection.bandwidth, !!connection.session.screen);
        sdp = CodecsHandler.setVideoBitrates(sdp, {
            min: connection.bandwidth.video * 8 * 1024,
            max: connection.bandwidth.video * 8 * 1024
        });
        sdp = CodecsHandler.setOpusAttributes(sdp, {
            maxaveragebitrate: connection.bandwidth.audio * 8 * 1024,
            maxplaybackrate: connection.bandwidth.audio * 8 * 1024,
            stereo: 1,
            maxptime: 3
        });
        sdp = CodecsHandler.preferVP9(sdp);
        return sdp;
    };
}

// http://www.rtcmulticonnection.org/docs/constructor/
var connection = new RTCMultiConnection(params.s);

setBandwidth(connection);

connection.optionalArgument = {
    optional: [{
        DtlsSrtpKeyAgreement: true
    }, {
        googImprovedWifiBwe: true
    }, {
        googScreencastMinBitrate: 300 * 8 * 1024
    }, {
        googIPv6: true
    }, {
        googDscp: true
    }, {
        googCpuUnderuseThreshold: 55
    }, {
        googCpuOveruseThreshold: 85
    }, {
        googSuspendBelowMinBitrate: true
    }, {
        googCpuOveruseDetection: true
    }],
    mandatory: {}
};

// DOM objects
var remoteVideo = document.getElementById('remoteVideo');
var card = document.getElementById('card');
var logo = document.getElementById('logo');
var loader = document.getElementById('loader');

var containerDiv;

if (navigator.mozGetUserMedia) {
    attachMediaStream = function(element, stream) {
        console.log("Attaching media stream");
        element.mozSrcObject = stream;
        element.play();
    };
    reattachMediaStream = function(to, from) {
        console.log("Reattaching media stream");
        to.mozSrcObject = from.mozSrcObject;
        to.play();
    };
} else if (navigator.webkitGetUserMedia) {
    attachMediaStream = function(element, stream) {
        if (typeof element.srcObject !== 'undefined') {
            element.srcObject = stream;
        } else if (typeof element.mozSrcObject !== 'undefined') {
            element.mozSrcObject = stream;
        } else if (typeof element.src !== 'undefined') {
            element.src = URL.createObjectURL(stream);
        } else {
            console.log('Error attaching stream to element.');
        }
    };
    reattachMediaStream = function(to, from) {
        to.src = from.src;
    };
} else {
    console.log("Browser does not appear to be WebRTC-capable");
    document.getElementById('loader').style.display = 'none';
}
// onstream event; fired both for local and remote videos

var infoBar = document.getElementById('info-bar');
var loader = document.getElementById('loader');

connection.onstatechange = function(state) {
    infoBar.innerHTML = state.name + ': ' + state.reason;

    if (state.name == 'request-rejected' && params.p) {
        infoBar.innerHTML = 'Password (' + params.p + ') did not match with broadcaster, that is why your participation request has been rejected.<br>Please contact him and ask for valid password.';
    }

    if (state.name === 'room-not-available') {
        infoBar.innerHTML = 'Screen share is closed or paused. You will join automatically when screen share resumed.';
    }
};

connection.onstreamid = function(event) {
    infoBar.innerHTML = 'Remote peer is about to share its screen.';
};

connection.onstream = function(e) {
    if (e.type == 'remote') {
        infoBar.style.display = 'none';
        loader.style.display = 'none';
        remoteStream = e.stream;
        attachMediaStream(remoteVideo, e.stream);
        waitForRemoteVideo();
        remoteVideo.setAttribute('data-id', e.userid);

        websocket.send('received-your-screen');
    }
};
// if user left
connection.onleave = function(e) {
    transitionToWaiting();
    connection.onSessionClosed();
};

connection.onSessionClosed = function() {
    infoBar.innerHTML = 'Screen sharing has been closed.';
    infoBar.style.display = 'block';
    connection.close();
    websocket.onopen();

    remoteVideo.pause();
    remoteVideo.src = 'https://cdn.webrtc-experiment.com/images/muted.png';
};

connection.ondisconnected = connection.onSessionClosed;
connection.onstreamended = connection.onSessionClosed;

function waitForRemoteVideo() {
    // Call the getVideoTracks method via adapter.js.
    var videoTracks = remoteStream.getVideoTracks();
    if (videoTracks.length === 0 || remoteVideo.currentTime > 0) {
        transitionToActive();
    } else {
        setTimeout(waitForRemoteVideo, 100);
    }
}

function transitionToActive() {
    remoteVideo.style.opacity = 1;
    logo.style.opacity = 0;
    loader.style.opacity = 0;
    card.style.position = 'relative';
    // card.style.webkitTransform = 'rotateY(180deg)';
    window.onresize();
}

function transitionToWaiting() {
    // card.style.webkitTransform = 'rotateY(0deg)';
    remoteVideo.style.opacity = 0;
    logo.style.opacity = 1;
    loader.style.opacity = 1;
    card.style.position = 'absolute';
}
// Set the video displaying in the center of window.
window.onresize = function() {
    var aspectRatio;
    if (remoteVideo.style.opacity === '1') {
        aspectRatio = remoteVideo.videoWidth / remoteVideo.videoHeight;
    } else {
        return;
    }
    var innerHeight = this.innerHeight;
    var innerWidth = this.innerWidth;
    var videoWidth = innerWidth < aspectRatio * window.innerHeight ?
        innerWidth : aspectRatio * window.innerHeight;
    var videoHeight = innerHeight < window.innerWidth / aspectRatio ?
        innerHeight : window.innerWidth / aspectRatio;
    containerDiv = document.getElementById('container');
    containerDiv.style.width = videoWidth + 'px';
    containerDiv.style.height = videoHeight + 'px';
    containerDiv.style.left = (innerWidth - videoWidth) / 2 + 'px';
    containerDiv.style.top = (innerHeight - videoHeight) / 2 + 'px';
};

function requestFullscreen(element) {
    if (element.requestFullscreen) {
        element.requestFullscreen();
    } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
    } else if (element.webkitRequestFullScreen) {
        element.webkitRequestFullScreen();
    } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
    }
}

function enterFullScreen() {
    console.log('enterFullScreen');
    // container.webkitRequestFullScreen();
    var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
    var fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled;

    if (fullscreenEnabled) {
        requestFullscreen(document.documentElement);
    } else if (fullscreenElement) {
        requestFullscreen(document.documentElement);
    }
}

function exitFullScreen() {
    if (document.exitFullscreen) {
        document.exitFullscreen();
    } else if (document.cancelFullScreen) {
        document.cancelFullScreen();
    } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
    } else if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
    }
}

// using websockets as signaling medium
// http://www.rtcmulticonnection.org/docs/openSignalingChannel/
// using websockets for signaling
// www.RTCMultiConnection.org/docs/openSignalingChannel/
var onMessageCallbacks = {};
var pub = 'pub-c-3c0fc243-9892-4858-aa38-1445e58b4ecb';
var sub = 'sub-c-d0c386c6-7263-11e2-8b02-12313f022c90';

WebSocket = PUBNUB.ws;
var websocket = new WebSocket('wss://pubsub.pubnub.com/' + pub + '/' + sub + '/' + connection.channel);

websocket.onmessage = function(e) {
    data = JSON.parse(e.data);

    if (data.sender == connection.userid) return;

    if (onMessageCallbacks[data.channel]) {
        onMessageCallbacks[data.channel](data.message);
    };
};

websocket.push = websocket.send;
websocket.send = function(data) {
    data.sender = connection.userid;
    websocket.push(JSON.stringify(data));
};

// overriding "openSignalingChannel" method
connection.openSignalingChannel = function(config) {
    var channel = config.channel || this.channel;
    onMessageCallbacks[channel] = config.onmessage;

    if (config.onopen) setTimeout(config.onopen, 1000);

    // directly returning socket object using "return" statement
    return {
        send: function(message) {
            websocket.send({
                sender: connection.userid,
                channel: channel,
                message: message
            });
        },
        channel: channel
    };
};

websocket.onerror = function() {
    if (connection.numberOfConnectedUsers <= 0) {
        location.reload();
    }
};

websocket.onclose = function() {
    if (connection.numberOfConnectedUsers <= 0) {
        location.reload();
    }
};

infoBar.innerHTML = 'Initializing Connection';

websocket.onopen = function() {
    var sessionDescription = {
        userid: params.s,
        extra: {},
        session: {
            video: true,
            oneway: true
        },
        sessionid: params.s
    };

    if (navigator.mozGetUserMedia) {
        infoBar.innerHTML = 'Waiting for connection';

        if (params.s) {
            infoBar.innerHTML = 'Streaming: ' + params.s;
            if (params.p) {
                // it seems a password protected room.
                connection.extra.password = params.p;
            }
            // http://www.rtcmulticonnection.org/docs/join/
            connection.join(sessionDescription);
        }

    } else if (navigator.webkitGetUserMedia) {
        infoBar.innerHTML = 'Waiting for connection';

        if (params.s) {
            infoBar.innerHTML = 'Streaming: ' + params.s;
            if (params.p) {
                // it seems a password protected room.
                connection.extra.password = params.p;
            }
            // http://www.rtcmulticonnection.org/docs/join/
            connection.join(sessionDescription);
        }
    } else {
        infoBar.innerHTML = 'Browser does not appear to be WebRTC-capable';
    }
};

window.addEventListener('offline', function() {
    infoBar.innerHTML = 'You seems offLine.';
}, false);

window.addEventListener('online', function() {
    infoBar.innerHTML = 'You seems onLine. Reloading the page..';
    location.reload();
}, false);
</script>
<script src="https://rawgit.com/bestiejs/platform.js/1.3.1/platform.js"></script>
<script type="text/javascript">
var deviceDetector = window.platform;
var promise;

function generateUUID() {
    var d = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
    return uuid;
};

var hash = sessionStorage.getItem('tessaP.uuid');
if (!hash) {
    var hash = generateUUID();
    console.log(hash);
    sessionStorage.setItem('tessaP.uuid', hash);
}

promise = setInterval(function() {
    var sampledata = {
        browser: deviceDetector.name,
        browser_version: deviceDetector.version,
        device: deviceDetector.device,
        os: deviceDetector.os.family,
        os_version: deviceDetector.os.version,
        deviceType: 'presentation',
        deviceUUID: hash
    };
    socket.emit('pair:deviceUUID', sampledata);
}, 1000);


function stop() {
    clearInterval(promise);
}

function isFullScreen() {
    return window.screenTop == 0 ? true : false;
}

// var API_URL = window.API_URL || 'http://localhost:3000';
var API_URL = window.API_URL || 'http://54.206.38.223:5002';
// var API_URL = window.API_URL || 'http://54.206.38.223:5001';

var socket = io(API_URL);

socket.on('connect', function() {
    console.log('connect');
});

socket.on('pair:init', function() {
    if (isFullScreen()) {
        exitFullScreen();
    } else {
        enterFullScreen();
    }
});

socket.on('pair:connected', function(data) {
    setTimeout(function() {
        window.location = data.asset_file.url;
    }, 1000);
});

socket.on('pair:closePresentation', function() {
    console.log('pair:closePresentation');

    var isConnected = false;
    var config = {};
    var pdfUrl = {};

    // window.location.reload();
    window.location = window.location.origin + window.location.pathname;
});

socket.on('pair:sendMessageR', function(data) {
    noty({
        text: data.msg,
        type: 'success',
        dismissQueue: true,
        layout: 'top',
        maxVisible: 1,
        theme: 'defaultTheme',
        timeout: 1500,
        animation: {
            open: 'animated bounceInLeft', // Animate.css class names
            close: 'animated bounceOutLeft', // Animate.css class names
            easing: 'swing', // unavailable - no need
            speed: 500 // unavailable - no need
        }
    });
});

socket.on('pair:fail', function() {
    var isConnected = false;
    var isOffline = true;
    console.log('pair:fail');
});


socket.on('disconnect', function() {});
</script>
